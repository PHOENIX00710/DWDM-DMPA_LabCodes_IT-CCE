def prune(c1, min_support):
    return {i: c1[i] for i in c1 if c1[i] >= min_support}
 
 
def join(C1, transactions, k):
    # Final Ck generated by joining elements of L1 based on k-1 values for each item
    Ck = {}              
    listOfKeysForCk=[]
    for key,value in C1.items():                   
        for key2,value2 in C1.items():
            tempList=[]                   # Stores the joined elements to form a new key
            isSame=True
            if(key2 == key):              # Continue if key is same
                continue
            
            tempList.append(key[0])
            tempList.append(key2[0])
            
            # If k>1 we iterate for k-1 elements and append if all k-1 are same    
            if(k > 1):
                for i in range(0,k-1):
                    if(key[i] != key2[i]):
                        isSame=False
                        break
                    tempList.append(key[i+1])
                    tempList.append(key2[i+1])
                    
            # We convert to tuple if k-1 are same at the end and we take set to remove duplicates that will be generated by appending key[i] again and again       
            if(isSame):
                listOfKeysForCk.append(tuple(set(tempList)))
                
    # We form a new dictionary of Ck
    for i in listOfKeysForCk:
        Ck[i]=0

    # After Joining we calculate the frequency for each item in Ck
    for tuples in Ck.keys():
        for value in transactions.values():
            exists=True
            string =str(value)
            # We convert each transaction to a string to check if each of our items in the tuple are there in the transaction or not. If they are we increase the frequency by 1
            for tup in tuples:
                if(string.find(str(tup)) == -1):
                    exists = False
                    break
            if(exists == True):
                Ck[tuples]+=1
    return Ck
 
 
# We take input for the transactions
n = int(input('Enter the number of transactions: '))
transactions = {}
for i in range(0, n):
    temp = []
    x = int(input(f'Enter the value for transaction T{i+1}, -1 to stop: '))
    while (x != -1):
        temp.append(x)
        x = int(input(f'Enter the value for transaction T{i+1}, -1 to stop: '))
    transactions[f"T{i+1}"] = temp

# We prepare C1
c1 = {}
for i in transactions.values():
    for j in i:
        if (j not in c1):
            c1[j] = 1
        else:
            c1[j] += 1
 
# For C1 we sort the by the numbers
initial_keys = c1.keys()
list1 = []
for i in initial_keys:
    tup = []
    tup.append(i)
    list1.append(tuple(tup))
list1.sort()
C1 = {}
for j in range(0, len(list1)):
    C1[list1[j]] = c1[j+1]
print(f"C1: {C1}")
 
 
# Take minimum support, C1 is your first candidate Key
min_support = int(input("Please enter the minimum support for the transactions: "))

# Initialize k and Ck
k=1 
Ck=C1
ans={}

while Ck: # While there are still items on CK
    # Call prune
    l1 = prune(Ck, min_support)
    print(f"L{k}: {l1}")
    
    if(len(l1) == 0):
        ans=Ck
    # Call Join
    Ck = join(l1, transactions, k)
    print(f"C{k}: {Ck}")
    
    #Increase k
    k+=1

print(f"The candidate item sets are {ans.keys()}") 
 
'''

Test case: ANS([1,2,3,5]) -->

1
2
5
-1
2
4
-1
2
3
-1
1
2
4
-1
1
3
-1
2
3
-1
1
3
-1
1
2
3
5
-1
1
2
3
-1 '''
 